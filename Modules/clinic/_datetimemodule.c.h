/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_modsupport.h"    // _PyArg_UnpackKeywords()

PyDoc_STRVAR(datetime_timedelta_total_seconds__doc__,
"total_seconds($self, /)\n"
"--\n"
"\n"
"Total seconds in the duration.");

#define DATETIME_TIMEDELTA_TOTAL_SECONDS_METHODDEF    \
    {"total_seconds", _PyCFunction_CAST(datetime_timedelta_total_seconds), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_timedelta_total_seconds__doc__},

static PyObject *
datetime_timedelta_total_seconds_impl(PyObject *self, PyTypeObject *defcls);

static PyObject *
datetime_timedelta_total_seconds(PyObject *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "total_seconds() takes no arguments");
        return NULL;
    }
    return datetime_timedelta_total_seconds_impl(self, defcls);
}

PyDoc_STRVAR(datetime_date_fromtimestamp__doc__,
"fromtimestamp($type, timestamp, /)\n"
"--\n"
"\n"
"Create a date from a POSIX timestamp.\n"
"\n"
"The timestamp is a number, e.g. created via time.time(), that is interpreted\n"
"as local time.");

#define DATETIME_DATE_FROMTIMESTAMP_METHODDEF    \
    {"fromtimestamp", _PyCFunction_CAST(datetime_date_fromtimestamp), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_date_fromtimestamp__doc__},

static PyObject *
datetime_date_fromtimestamp_impl(PyTypeObject *type, PyTypeObject *defcls,
                                 PyObject *timestamp);

static PyObject *
datetime_date_fromtimestamp(PyTypeObject *type, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromtimestamp",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *timestamp;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    timestamp = args[0];
    return_value = datetime_date_fromtimestamp_impl(type, defcls, timestamp);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date_fromordinal__doc__,
"fromordinal($type, ordinal, /)\n"
"--\n"
"\n"
"int -> date corresponding to a proleptic Gregorian ordinal.\n"
"\n"
"Return new date from proleptic Gregorian ordinal.  Raises ValueError\n"
"if the ordinal is out of range.");

#define DATETIME_DATE_FROMORDINAL_METHODDEF    \
    {"fromordinal", _PyCFunction_CAST(datetime_date_fromordinal), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_date_fromordinal__doc__},

static PyObject *
datetime_date_fromordinal_impl(PyObject *cls, PyTypeObject *defcls,
                               int ordinal);

static PyObject *
datetime_date_fromordinal(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromordinal",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    int ordinal;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    ordinal = PyLong_AsInt(args[0]);
    if (ordinal == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = datetime_date_fromordinal_impl((PyObject *)cls, defcls, ordinal);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date_fromisoformat__doc__,
"fromisoformat($type, dtstr, /)\n"
"--\n"
"\n"
"str -> Construct a date from a string in ISO 8601 format.\n"
"\n"
"Return the new date from a string as generated by date.isoformat().");

#define DATETIME_DATE_FROMISOFORMAT_METHODDEF    \
    {"fromisoformat", _PyCFunction_CAST(datetime_date_fromisoformat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_date_fromisoformat__doc__},

static PyObject *
datetime_date_fromisoformat_impl(PyObject *cls, PyTypeObject *defcls,
                                 PyObject *dtstr);

static PyObject *
datetime_date_fromisoformat(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromisoformat",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dtstr;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dtstr = args[0];
    return_value = datetime_date_fromisoformat_impl((PyObject *)cls, defcls, dtstr);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date_fromisocalendar__doc__,
"fromisocalendar($type, /, year, week, day)\n"
"--\n"
"\n"
"int, int, int -> Construct a date from the ISO year, week number and weekday.\n"
"\n"
"This is the inverse of the date.isocalendar() function.");

#define DATETIME_DATE_FROMISOCALENDAR_METHODDEF    \
    {"fromisocalendar", _PyCFunction_CAST(datetime_date_fromisocalendar), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_date_fromisocalendar__doc__},

static PyObject *
datetime_date_fromisocalendar_impl(PyObject *cls, PyTypeObject *defcls,
                                   int year, int week, int day);

static PyObject *
datetime_date_fromisocalendar(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 3
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(week), &_Py_ID(day), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "week", "day", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromisocalendar",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[3];
    int year;
    int week;
    int day;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 3, 3, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!calendar_int_converter(args[0], &year)) {
        goto exit;
    }
    if (!calendar_int_converter(args[1], &week)) {
        goto exit;
    }
    if (!calendar_int_converter(args[2], &day)) {
        goto exit;
    }
    return_value = datetime_date_fromisocalendar_impl((PyObject *)cls, defcls, year, week, day);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date_strftime__doc__,
"strftime($self, /, format)\n"
"--\n"
"\n"
"format -> strftime() style string.");

#define DATETIME_DATE_STRFTIME_METHODDEF    \
    {"strftime", _PyCFunction_CAST(datetime_date_strftime), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_date_strftime__doc__},

static PyObject *
datetime_date_strftime_impl(PyDateTime_Date *self, PyTypeObject *defcls,
                            PyObject *format);

static PyObject *
datetime_date_strftime(PyDateTime_Date *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(format), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"format", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "strftime",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *format;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!PyUnicode_Check(args[0])) {
        _PyArg_BadArgument("strftime", "argument 'format'", "str", args[0]);
        goto exit;
    }
    format = args[0];
    return_value = datetime_date_strftime_impl(self, defcls, format);

exit:
    return return_value;
}

static PyObject *
iso_calendar_date_new_impl(PyTypeObject *type, int year, int week,
                           int weekday);

static PyObject *
iso_calendar_date_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 3
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(week), &_Py_ID(weekday), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "week", "weekday", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "IsoCalendarDate",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[3];
    PyObject * const *fastargs;
    Py_ssize_t nargs = PyTuple_GET_SIZE(args);
    int year;
    int week;
    int weekday;

    fastargs = _PyArg_UnpackKeywords(_PyTuple_CAST(args)->ob_item, nargs, kwargs, NULL, &_parser, 3, 3, 0, argsbuf);
    if (!fastargs) {
        goto exit;
    }
    year = PyLong_AsInt(fastargs[0]);
    if (year == -1 && PyErr_Occurred()) {
        goto exit;
    }
    week = PyLong_AsInt(fastargs[1]);
    if (week == -1 && PyErr_Occurred()) {
        goto exit;
    }
    weekday = PyLong_AsInt(fastargs[2]);
    if (weekday == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = iso_calendar_date_new_impl(type, year, week, weekday);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date_isocalendar__doc__,
"isocalendar($self, /)\n"
"--\n"
"\n"
"Return a named tuple containing ISO year, week number, and weekday.");

#define DATETIME_DATE_ISOCALENDAR_METHODDEF    \
    {"isocalendar", _PyCFunction_CAST(datetime_date_isocalendar), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_date_isocalendar__doc__},

static PyObject *
datetime_date_isocalendar_impl(PyDateTime_Date *self, PyTypeObject *defcls);

static PyObject *
datetime_date_isocalendar(PyDateTime_Date *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "isocalendar() takes no arguments");
        return NULL;
    }
    return datetime_date_isocalendar_impl(self, defcls);
}

PyDoc_STRVAR(datetime_date_replace__doc__,
"replace($self, /, year=unchanged, month=unchanged, day=unchanged)\n"
"--\n"
"\n"
"Return date with new specified fields.");

#define DATETIME_DATE_REPLACE_METHODDEF    \
    {"replace", _PyCFunction_CAST(datetime_date_replace), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_date_replace__doc__},

static PyObject *
datetime_date_replace_impl(PyDateTime_Date *self, PyTypeObject *defcls,
                           int year, int month, int day);

static PyObject *
datetime_date_replace(PyDateTime_Date *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 3
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(month), &_Py_ID(day), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "month", "day", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "replace",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[3];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int year = GET_YEAR(self);
    int month = GET_MONTH(self);
    int day = GET_DAY(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 3, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        year = PyLong_AsInt(args[0]);
        if (year == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        month = PyLong_AsInt(args[1]);
        if (month == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    day = PyLong_AsInt(args[2]);
    if (day == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_pos:
    return_value = datetime_date_replace_impl(self, defcls, year, month, day);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_date___replace____doc__,
"__replace__($self, /, year=unchanged, month=unchanged, day=unchanged)\n"
"--\n"
"\n"
"The same as replace().");

#define DATETIME_DATE___REPLACE___METHODDEF    \
    {"__replace__", _PyCFunction_CAST(datetime_date___replace__), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_date___replace____doc__},

static PyObject *
datetime_date___replace___impl(PyDateTime_Date *self, PyTypeObject *defcls,
                               int year, int month, int day);

static PyObject *
datetime_date___replace__(PyDateTime_Date *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 3
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(month), &_Py_ID(day), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "month", "day", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "__replace__",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[3];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int year = GET_YEAR(self);
    int month = GET_MONTH(self);
    int day = GET_DAY(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 3, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        year = PyLong_AsInt(args[0]);
        if (year == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        month = PyLong_AsInt(args[1]);
        if (month == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    day = PyLong_AsInt(args[2]);
    if (day == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_pos:
    return_value = datetime_date___replace___impl(self, defcls, year, month, day);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_tzinfo_fromutc__doc__,
"fromutc($self, dt, /)\n"
"--\n"
"\n"
"datetime in UTC -> datetime in local time.");

#define DATETIME_TZINFO_FROMUTC_METHODDEF    \
    {"fromutc", _PyCFunction_CAST(datetime_tzinfo_fromutc), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_tzinfo_fromutc__doc__},

static PyObject *
datetime_tzinfo_fromutc_impl(PyDateTime_TZInfo *self, PyTypeObject *defcls,
                             PyObject *dt);

static PyObject *
datetime_tzinfo_fromutc(PyDateTime_TZInfo *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromutc",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dt;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dt = args[0];
    return_value = datetime_tzinfo_fromutc_impl(self, defcls, dt);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_timezone_tzname__doc__,
"tzname($self, dt, /)\n"
"--\n"
"\n"
"Return the name specified at timezone creation, or offset as \'UTC(+|-)HH:MM\'.\n"
"\n"
"If name is specified when timezone is created, returns the name.\n"
"Otherwise returns offset as \'UTC(+|-)HH:MM\'.");

#define DATETIME_TIMEZONE_TZNAME_METHODDEF    \
    {"tzname", _PyCFunction_CAST(datetime_timezone_tzname), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_timezone_tzname__doc__},

static PyObject *
datetime_timezone_tzname_impl(PyDateTime_TimeZone *self,
                              PyTypeObject *defcls, PyObject *dt);

static PyObject *
datetime_timezone_tzname(PyDateTime_TimeZone *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "tzname",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dt;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dt = args[0];
    return_value = datetime_timezone_tzname_impl(self, defcls, dt);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_timezone_utcoffset__doc__,
"utcoffset($self, dt, /)\n"
"--\n"
"\n"
"Return fixed offset.");

#define DATETIME_TIMEZONE_UTCOFFSET_METHODDEF    \
    {"utcoffset", _PyCFunction_CAST(datetime_timezone_utcoffset), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_timezone_utcoffset__doc__},

static PyObject *
datetime_timezone_utcoffset_impl(PyDateTime_TimeZone *self,
                                 PyTypeObject *defcls, PyObject *dt);

static PyObject *
datetime_timezone_utcoffset(PyDateTime_TimeZone *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "utcoffset",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dt;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dt = args[0];
    return_value = datetime_timezone_utcoffset_impl(self, defcls, dt);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_timezone_dst__doc__,
"dst($self, dt, /)\n"
"--\n"
"\n"
"Return None.");

#define DATETIME_TIMEZONE_DST_METHODDEF    \
    {"dst", _PyCFunction_CAST(datetime_timezone_dst), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_timezone_dst__doc__},

static PyObject *
datetime_timezone_dst_impl(PyDateTime_TimeZone *self, PyTypeObject *defcls,
                           PyObject *dt);

static PyObject *
datetime_timezone_dst(PyDateTime_TimeZone *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "dst",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dt;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dt = args[0];
    return_value = datetime_timezone_dst_impl(self, defcls, dt);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_timezone_fromutc__doc__,
"fromutc($self, dt, /)\n"
"--\n"
"\n"
"datetime in UTC -> datetime in local time.");

#define DATETIME_TIMEZONE_FROMUTC_METHODDEF    \
    {"fromutc", _PyCFunction_CAST(datetime_timezone_fromutc), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_timezone_fromutc__doc__},

static PyObject *
datetime_timezone_fromutc_impl(PyDateTime_TimeZone *self,
                               PyTypeObject *defcls, PyDateTime_DateTime *dt);

static PyObject *
datetime_timezone_fromutc(PyDateTime_TimeZone *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromutc",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyDateTime_DateTime *dt;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dt = (PyDateTime_DateTime *)args[0];
    return_value = datetime_timezone_fromutc_impl(self, defcls, dt);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_time_utcoffset__doc__,
"utcoffset($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.utcoffset(self).");

#define DATETIME_TIME_UTCOFFSET_METHODDEF    \
    {"utcoffset", _PyCFunction_CAST(datetime_time_utcoffset), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_utcoffset__doc__},

static PyObject *
datetime_time_utcoffset_impl(PyDateTime_Time *self, PyTypeObject *defcls);

static PyObject *
datetime_time_utcoffset(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "utcoffset() takes no arguments");
        return NULL;
    }
    return datetime_time_utcoffset_impl(self, defcls);
}

PyDoc_STRVAR(datetime_time_dst__doc__,
"dst($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.dst(self).");

#define DATETIME_TIME_DST_METHODDEF    \
    {"dst", _PyCFunction_CAST(datetime_time_dst), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_dst__doc__},

static PyObject *
datetime_time_dst_impl(PyDateTime_Time *self, PyTypeObject *defcls);

static PyObject *
datetime_time_dst(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "dst() takes no arguments");
        return NULL;
    }
    return datetime_time_dst_impl(self, defcls);
}

PyDoc_STRVAR(datetime_time_tzname__doc__,
"tzname($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.tzname(self).");

#define DATETIME_TIME_TZNAME_METHODDEF    \
    {"tzname", _PyCFunction_CAST(datetime_time_tzname), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_tzname__doc__},

static PyObject *
datetime_time_tzname_impl(PyDateTime_Time *self, PyTypeObject *defcls);

static PyObject *
datetime_time_tzname(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "tzname() takes no arguments");
        return NULL;
    }
    return datetime_time_tzname_impl(self, defcls);
}

PyDoc_STRVAR(datetime_time_isoformat__doc__,
"isoformat($self, /, timespec=<unrepresentable>)\n"
"--\n"
"\n"
"Return string in ISO 8601 format, [HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\n"
"\n"
"The optional argument timespec specifies the number of additional terms\n"
"of the time to include. Valid options are \'auto\', \'hours\', \'minutes\',\n"
"\'seconds\', \'milliseconds\' and \'microseconds\'.");

#define DATETIME_TIME_ISOFORMAT_METHODDEF    \
    {"isoformat", _PyCFunction_CAST(datetime_time_isoformat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_isoformat__doc__},

static PyObject *
datetime_time_isoformat_impl(PyDateTime_Time *self, PyTypeObject *defcls,
                             const char *timespec);

static PyObject *
datetime_time_isoformat(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(timespec), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"timespec", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "isoformat",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    const char *timespec = NULL;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (!PyUnicode_Check(args[0])) {
        _PyArg_BadArgument("isoformat", "argument 'timespec'", "str", args[0]);
        goto exit;
    }
    Py_ssize_t timespec_length;
    timespec = PyUnicode_AsUTF8AndSize(args[0], &timespec_length);
    if (timespec == NULL) {
        goto exit;
    }
    if (strlen(timespec) != (size_t)timespec_length) {
        PyErr_SetString(PyExc_ValueError, "embedded null character");
        goto exit;
    }
skip_optional_pos:
    return_value = datetime_time_isoformat_impl(self, defcls, timespec);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_time_strftime__doc__,
"strftime($self, /, format)\n"
"--\n"
"\n"
"format -> strftime() style string.");

#define DATETIME_TIME_STRFTIME_METHODDEF    \
    {"strftime", _PyCFunction_CAST(datetime_time_strftime), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_strftime__doc__},

static PyObject *
datetime_time_strftime_impl(PyDateTime_Time *self, PyTypeObject *defcls,
                            PyObject *format);

static PyObject *
datetime_time_strftime(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(format), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"format", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "strftime",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *format;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!PyUnicode_Check(args[0])) {
        _PyArg_BadArgument("strftime", "argument 'format'", "str", args[0]);
        goto exit;
    }
    format = args[0];
    return_value = datetime_time_strftime_impl(self, defcls, format);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_time_replace__doc__,
"replace($self, /, hour=unchanged, minute=unchanged, second=unchanged,\n"
"        microsecond=unchanged, tzinfo=unchanged, *, fold=unchanged)\n"
"--\n"
"\n"
"Return time with new specified fields.");

#define DATETIME_TIME_REPLACE_METHODDEF    \
    {"replace", _PyCFunction_CAST(datetime_time_replace), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time_replace__doc__},

static PyObject *
datetime_time_replace_impl(PyDateTime_Time *self, PyTypeObject *defcls,
                           int hour, int minute, int second, int microsecond,
                           PyObject *tzinfo, int fold);

static PyObject *
datetime_time_replace(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 6
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(hour), &_Py_ID(minute), &_Py_ID(second), &_Py_ID(microsecond), &_Py_ID(tzinfo), &_Py_ID(fold), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"hour", "minute", "second", "microsecond", "tzinfo", "fold", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "replace",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[6];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int hour = TIME_GET_HOUR(self);
    int minute = TIME_GET_MINUTE(self);
    int second = TIME_GET_SECOND(self);
    int microsecond = TIME_GET_MICROSECOND(self);
    PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;
    int fold = TIME_GET_FOLD(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 5, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        hour = PyLong_AsInt(args[0]);
        if (hour == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        minute = PyLong_AsInt(args[1]);
        if (minute == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[2]) {
        second = PyLong_AsInt(args[2]);
        if (second == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[3]) {
        microsecond = PyLong_AsInt(args[3]);
        if (microsecond == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[4]) {
        tzinfo = args[4];
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
skip_optional_pos:
    if (!noptargs) {
        goto skip_optional_kwonly;
    }
    fold = PyLong_AsInt(args[5]);
    if (fold == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_kwonly:
    return_value = datetime_time_replace_impl(self, defcls, hour, minute, second, microsecond, tzinfo, fold);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_time___replace____doc__,
"__replace__($self, /, hour=unchanged, minute=unchanged,\n"
"            second=unchanged, microsecond=unchanged, tzinfo=unchanged,\n"
"            *, fold=unchanged)\n"
"--\n"
"\n"
"The same as replace().");

#define DATETIME_TIME___REPLACE___METHODDEF    \
    {"__replace__", _PyCFunction_CAST(datetime_time___replace__), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_time___replace____doc__},

static PyObject *
datetime_time___replace___impl(PyDateTime_Time *self, PyTypeObject *defcls,
                               int hour, int minute, int second,
                               int microsecond, PyObject *tzinfo, int fold);

static PyObject *
datetime_time___replace__(PyDateTime_Time *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 6
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(hour), &_Py_ID(minute), &_Py_ID(second), &_Py_ID(microsecond), &_Py_ID(tzinfo), &_Py_ID(fold), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"hour", "minute", "second", "microsecond", "tzinfo", "fold", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "__replace__",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[6];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int hour = TIME_GET_HOUR(self);
    int minute = TIME_GET_MINUTE(self);
    int second = TIME_GET_SECOND(self);
    int microsecond = TIME_GET_MICROSECOND(self);
    PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;
    int fold = TIME_GET_FOLD(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 5, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        hour = PyLong_AsInt(args[0]);
        if (hour == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        minute = PyLong_AsInt(args[1]);
        if (minute == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[2]) {
        second = PyLong_AsInt(args[2]);
        if (second == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[3]) {
        microsecond = PyLong_AsInt(args[3]);
        if (microsecond == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[4]) {
        tzinfo = args[4];
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
skip_optional_pos:
    if (!noptargs) {
        goto skip_optional_kwonly;
    }
    fold = PyLong_AsInt(args[5]);
    if (fold == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_kwonly:
    return_value = datetime_time___replace___impl(self, defcls, hour, minute, second, microsecond, tzinfo, fold);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_time_fromisoformat__doc__,
"fromisoformat($type, tstr, /)\n"
"--\n"
"\n"
"string -> time from a string in ISO 8601 format.");

#define DATETIME_TIME_FROMISOFORMAT_METHODDEF    \
    {"fromisoformat", _PyCFunction_CAST(datetime_time_fromisoformat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_time_fromisoformat__doc__},

static PyObject *
datetime_time_fromisoformat_impl(PyObject *cls, PyTypeObject *defcls,
                                 PyObject *tstr);

static PyObject *
datetime_time_fromisoformat(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromisoformat",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *tstr;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    tstr = args[0];
    return_value = datetime_time_fromisoformat_impl((PyObject *)cls, defcls, tstr);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_now__doc__,
"now($type, /, tz=None)\n"
"--\n"
"\n"
"Returns new datetime object representing current time local to tz.\n"
"\n"
"  tz\n"
"    Timezone object.\n"
"\n"
"If no tz is specified, uses local timezone.");

#define DATETIME_DATETIME_NOW_METHODDEF    \
    {"now", _PyCFunction_CAST(datetime_datetime_now), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_datetime_now__doc__},

static PyObject *
datetime_datetime_now_impl(PyTypeObject *type, PyTypeObject *defcls,
                           PyObject *tz);

static PyObject *
datetime_datetime_now(PyTypeObject *type, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(tz), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"tz", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "now",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    PyObject *tz = Py_None;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    tz = args[0];
skip_optional_pos:
    return_value = datetime_datetime_now_impl(type, defcls, tz);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_fromtimestamp__doc__,
"fromtimestamp($type, /, timestamp, tz=None)\n"
"--\n"
"\n"
"timestamp[, tz] -> tz\'s local time from POSIX timestamp.\n"
"\n"
"Return new local datetime from timestamp (Python timestamp -- a double).");

#define DATETIME_DATETIME_FROMTIMESTAMP_METHODDEF    \
    {"fromtimestamp", _PyCFunction_CAST(datetime_datetime_fromtimestamp), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_datetime_fromtimestamp__doc__},

static PyObject *
datetime_datetime_fromtimestamp_impl(PyObject *cls, PyTypeObject *defcls,
                                     PyObject *timestamp, PyObject *tzinfo);

static PyObject *
datetime_datetime_fromtimestamp(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 2
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(timestamp), &_Py_ID(tz), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"timestamp", "tz", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromtimestamp",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
    PyObject *timestamp;
    PyObject *tzinfo = Py_None;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 2, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    timestamp = args[0];
    if (!noptargs) {
        goto skip_optional_pos;
    }
    tzinfo = args[1];
skip_optional_pos:
    return_value = datetime_datetime_fromtimestamp_impl((PyObject *)cls, defcls, timestamp, tzinfo);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_strptime__doc__,
"strptime($type, string, format, /)\n"
"--\n"
"\n"
"string, format -> new datetime parsed from a string (like time.strptime()).\n"
"\n"
"Return new datetime from _strptime.strptime_datetime().");

#define DATETIME_DATETIME_STRPTIME_METHODDEF    \
    {"strptime", _PyCFunction_CAST(datetime_datetime_strptime), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_datetime_strptime__doc__},

static PyObject *
datetime_datetime_strptime_impl(PyObject *cls, PyTypeObject *defcls,
                                PyObject *string, PyObject *format);

static PyObject *
datetime_datetime_strptime(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", "", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "strptime",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    PyObject *string;
    PyObject *format;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 2, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    string = args[0];
    format = args[1];
    return_value = datetime_datetime_strptime_impl((PyObject *)cls, defcls, string, format);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_combine__doc__,
"combine($type, /, date, time, tzinfo=<unrepresentable>)\n"
"--\n"
"\n"
"date, time -> datetime with same date and time fields.\n"
"\n"
"Return new datetime from date/datetime and time arguments.");

#define DATETIME_DATETIME_COMBINE_METHODDEF    \
    {"combine", _PyCFunction_CAST(datetime_datetime_combine), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_datetime_combine__doc__},

static PyObject *
datetime_datetime_combine_impl(PyObject *cls, PyTypeObject *defcls,
                               PyObject *date, PyObject *time,
                               PyObject *tzinfo);

static PyObject *
datetime_datetime_combine(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 3
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(date), &_Py_ID(time), &_Py_ID(tzinfo), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"date", "time", "tzinfo", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "combine",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[3];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 2;
    PyObject *date;
    PyObject *time;
    PyObject *tzinfo = NULL;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 2, 3, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!PyObject_TypeCheck(args[0], clinic_state()->PyDateTime_DateType)) {
        _PyArg_BadArgument("combine", "argument 'date'", (clinic_state()->PyDateTime_DateType)->tp_name, args[0]);
        goto exit;
    }
    date = args[0];
    if (!PyObject_TypeCheck(args[1], clinic_state()->PyDateTime_TimeType)) {
        _PyArg_BadArgument("combine", "argument 'time'", (clinic_state()->PyDateTime_TimeType)->tp_name, args[1]);
        goto exit;
    }
    time = args[1];
    if (!noptargs) {
        goto skip_optional_pos;
    }
    tzinfo = args[2];
skip_optional_pos:
    return_value = datetime_datetime_combine_impl((PyObject *)cls, defcls, date, time, tzinfo);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_fromisoformat__doc__,
"fromisoformat($type, dtstr, /)\n"
"--\n"
"\n"
"string -> datetime from a string in most ISO 8601 formats");

#define DATETIME_DATETIME_FROMISOFORMAT_METHODDEF    \
    {"fromisoformat", _PyCFunction_CAST(datetime_datetime_fromisoformat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS|METH_CLASS, datetime_datetime_fromisoformat__doc__},

static PyObject *
datetime_datetime_fromisoformat_impl(PyObject *cls, PyTypeObject *defcls,
                                     PyObject *dtstr);

static PyObject *
datetime_datetime_fromisoformat(PyTypeObject *cls, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "fromisoformat",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *dtstr;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 1, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dtstr = args[0];
    return_value = datetime_datetime_fromisoformat_impl((PyObject *)cls, defcls, dtstr);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_tzname__doc__,
"tzname($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.tzname(self).");

#define DATETIME_DATETIME_TZNAME_METHODDEF    \
    {"tzname", _PyCFunction_CAST(datetime_datetime_tzname), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_tzname__doc__},

static PyObject *
datetime_datetime_tzname_impl(PyObject *self, PyTypeObject *defcls);

static PyObject *
datetime_datetime_tzname(PyObject *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "tzname() takes no arguments");
        return NULL;
    }
    return datetime_datetime_tzname_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_utcoffset__doc__,
"utcoffset($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.utcoffset(self).");

#define DATETIME_DATETIME_UTCOFFSET_METHODDEF    \
    {"utcoffset", _PyCFunction_CAST(datetime_datetime_utcoffset), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_utcoffset__doc__},

static PyObject *
datetime_datetime_utcoffset_impl(PyObject *self, PyTypeObject *defcls);

static PyObject *
datetime_datetime_utcoffset(PyObject *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "utcoffset() takes no arguments");
        return NULL;
    }
    return datetime_datetime_utcoffset_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_dst__doc__,
"dst($self, /)\n"
"--\n"
"\n"
"Return self.tzinfo.dst(self).");

#define DATETIME_DATETIME_DST_METHODDEF    \
    {"dst", _PyCFunction_CAST(datetime_datetime_dst), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_dst__doc__},

static PyObject *
datetime_datetime_dst_impl(PyObject *self, PyTypeObject *defcls);

static PyObject *
datetime_datetime_dst(PyObject *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "dst() takes no arguments");
        return NULL;
    }
    return datetime_datetime_dst_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_isoformat__doc__,
"isoformat($self, /, sep=\'T\', timespec=<unrepresentable>)\n"
"--\n"
"\n"
"[sep] -> string in ISO 8601 format,\n"
"\n"
"YYYY-MM-DDT[HH[:MM[:SS[.mmm[uuu]]]]][+HH:MM].\n"
"sep is used to separate the year from the time, and defaults to \'T\'.\n"
"The optional argument timespec specifies the number of additional terms\n"
"of the time to include. Valid options are \'auto\', \'hours\', \'minutes\',\n"
"\'seconds\', \'milliseconds\' and \'microseconds\'.");

#define DATETIME_DATETIME_ISOFORMAT_METHODDEF    \
    {"isoformat", _PyCFunction_CAST(datetime_datetime_isoformat), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_isoformat__doc__},

static PyObject *
datetime_datetime_isoformat_impl(PyDateTime_DateTime *self,
                                 PyTypeObject *defcls, int sep,
                                 const char *timespec);

static PyObject *
datetime_datetime_isoformat(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 2
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(sep), &_Py_ID(timespec), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"sep", "timespec", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "isoformat",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int sep = 'T';
    const char *timespec = NULL;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 2, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        if (!PyUnicode_Check(args[0])) {
            _PyArg_BadArgument("isoformat", "argument 'sep'", "a unicode character", args[0]);
            goto exit;
        }
        if (PyUnicode_GET_LENGTH(args[0]) != 1) {
            _PyArg_BadArgument("isoformat", "argument 'sep'", "a unicode character", args[0]);
            goto exit;
        }
        sep = PyUnicode_READ_CHAR(args[0], 0);
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (!PyUnicode_Check(args[1])) {
        _PyArg_BadArgument("isoformat", "argument 'timespec'", "str", args[1]);
        goto exit;
    }
    Py_ssize_t timespec_length;
    timespec = PyUnicode_AsUTF8AndSize(args[1], &timespec_length);
    if (timespec == NULL) {
        goto exit;
    }
    if (strlen(timespec) != (size_t)timespec_length) {
        PyErr_SetString(PyExc_ValueError, "embedded null character");
        goto exit;
    }
skip_optional_pos:
    return_value = datetime_datetime_isoformat_impl(self, defcls, sep, timespec);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_replace__doc__,
"replace($self, /, year=unchanged, month=unchanged, day=unchanged,\n"
"        hour=unchanged, minute=unchanged, second=unchanged,\n"
"        microsecond=unchanged, tzinfo=unchanged, *, fold=unchanged)\n"
"--\n"
"\n"
"Return datetime with new specified fields.");

#define DATETIME_DATETIME_REPLACE_METHODDEF    \
    {"replace", _PyCFunction_CAST(datetime_datetime_replace), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_replace__doc__},

static PyObject *
datetime_datetime_replace_impl(PyDateTime_DateTime *self,
                               PyTypeObject *defcls, int year, int month,
                               int day, int hour, int minute, int second,
                               int microsecond, PyObject *tzinfo, int fold);

static PyObject *
datetime_datetime_replace(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 9
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(month), &_Py_ID(day), &_Py_ID(hour), &_Py_ID(minute), &_Py_ID(second), &_Py_ID(microsecond), &_Py_ID(tzinfo), &_Py_ID(fold), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "month", "day", "hour", "minute", "second", "microsecond", "tzinfo", "fold", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "replace",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[9];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int year = GET_YEAR(self);
    int month = GET_MONTH(self);
    int day = GET_DAY(self);
    int hour = DATE_GET_HOUR(self);
    int minute = DATE_GET_MINUTE(self);
    int second = DATE_GET_SECOND(self);
    int microsecond = DATE_GET_MICROSECOND(self);
    PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;
    int fold = DATE_GET_FOLD(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 8, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        year = PyLong_AsInt(args[0]);
        if (year == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        month = PyLong_AsInt(args[1]);
        if (month == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[2]) {
        day = PyLong_AsInt(args[2]);
        if (day == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[3]) {
        hour = PyLong_AsInt(args[3]);
        if (hour == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[4]) {
        minute = PyLong_AsInt(args[4]);
        if (minute == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[5]) {
        second = PyLong_AsInt(args[5]);
        if (second == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[6]) {
        microsecond = PyLong_AsInt(args[6]);
        if (microsecond == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[7]) {
        tzinfo = args[7];
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
skip_optional_pos:
    if (!noptargs) {
        goto skip_optional_kwonly;
    }
    fold = PyLong_AsInt(args[8]);
    if (fold == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_kwonly:
    return_value = datetime_datetime_replace_impl(self, defcls, year, month, day, hour, minute, second, microsecond, tzinfo, fold);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime___replace____doc__,
"__replace__($self, /, year=unchanged, month=unchanged, day=unchanged,\n"
"            hour=unchanged, minute=unchanged, second=unchanged,\n"
"            microsecond=unchanged, tzinfo=unchanged, *, fold=unchanged)\n"
"--\n"
"\n"
"The same as replace().");

#define DATETIME_DATETIME___REPLACE___METHODDEF    \
    {"__replace__", _PyCFunction_CAST(datetime_datetime___replace__), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime___replace____doc__},

static PyObject *
datetime_datetime___replace___impl(PyDateTime_DateTime *self,
                                   PyTypeObject *defcls, int year, int month,
                                   int day, int hour, int minute, int second,
                                   int microsecond, PyObject *tzinfo,
                                   int fold);

static PyObject *
datetime_datetime___replace__(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 9
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(year), &_Py_ID(month), &_Py_ID(day), &_Py_ID(hour), &_Py_ID(minute), &_Py_ID(second), &_Py_ID(microsecond), &_Py_ID(tzinfo), &_Py_ID(fold), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"year", "month", "day", "hour", "minute", "second", "microsecond", "tzinfo", "fold", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "__replace__",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[9];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int year = GET_YEAR(self);
    int month = GET_MONTH(self);
    int day = GET_DAY(self);
    int hour = DATE_GET_HOUR(self);
    int minute = DATE_GET_MINUTE(self);
    int second = DATE_GET_SECOND(self);
    int microsecond = DATE_GET_MICROSECOND(self);
    PyObject *tzinfo = HASTZINFO(self) ? self->tzinfo : Py_None;
    int fold = DATE_GET_FOLD(self);

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 8, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[0]) {
        year = PyLong_AsInt(args[0]);
        if (year == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[1]) {
        month = PyLong_AsInt(args[1]);
        if (month == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[2]) {
        day = PyLong_AsInt(args[2]);
        if (day == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[3]) {
        hour = PyLong_AsInt(args[3]);
        if (hour == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[4]) {
        minute = PyLong_AsInt(args[4]);
        if (minute == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[5]) {
        second = PyLong_AsInt(args[5]);
        if (second == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[6]) {
        microsecond = PyLong_AsInt(args[6]);
        if (microsecond == -1 && PyErr_Occurred()) {
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[7]) {
        tzinfo = args[7];
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
skip_optional_pos:
    if (!noptargs) {
        goto skip_optional_kwonly;
    }
    fold = PyLong_AsInt(args[8]);
    if (fold == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_kwonly:
    return_value = datetime_datetime___replace___impl(self, defcls, year, month, day, hour, minute, second, microsecond, tzinfo, fold);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_astimezone__doc__,
"astimezone($self, /, tz=None)\n"
"--\n"
"\n"
"tz -> convert to local time in new timezone tz.");

#define DATETIME_DATETIME_ASTIMEZONE_METHODDEF    \
    {"astimezone", _PyCFunction_CAST(datetime_datetime_astimezone), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_astimezone__doc__},

static PyObject *
datetime_datetime_astimezone_impl(PyDateTime_DateTime *self,
                                  PyTypeObject *defcls, PyObject *tzinfo);

static PyObject *
datetime_datetime_astimezone(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(tz), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"tz", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "astimezone",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    PyObject *tzinfo = Py_None;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser, 0, 1, 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    tzinfo = args[0];
skip_optional_pos:
    return_value = datetime_datetime_astimezone_impl(self, defcls, tzinfo);

exit:
    return return_value;
}

PyDoc_STRVAR(datetime_datetime_timetuple__doc__,
"timetuple($self, /)\n"
"--\n"
"\n"
"Return time tuple, compatible with time.localtime().");

#define DATETIME_DATETIME_TIMETUPLE_METHODDEF    \
    {"timetuple", _PyCFunction_CAST(datetime_datetime_timetuple), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_timetuple__doc__},

static PyObject *
datetime_datetime_timetuple_impl(PyDateTime_DateTime *self,
                                 PyTypeObject *defcls);

static PyObject *
datetime_datetime_timetuple(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "timetuple() takes no arguments");
        return NULL;
    }
    return datetime_datetime_timetuple_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_timestamp__doc__,
"timestamp($self, /)\n"
"--\n"
"\n"
"Return POSIX timestamp as float.");

#define DATETIME_DATETIME_TIMESTAMP_METHODDEF    \
    {"timestamp", _PyCFunction_CAST(datetime_datetime_timestamp), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_timestamp__doc__},

static PyObject *
datetime_datetime_timestamp_impl(PyDateTime_DateTime *self,
                                 PyTypeObject *defcls);

static PyObject *
datetime_datetime_timestamp(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "timestamp() takes no arguments");
        return NULL;
    }
    return datetime_datetime_timestamp_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_getdate__doc__,
"date($self, /)\n"
"--\n"
"\n"
"Return date object with same year, month and day.");

#define DATETIME_DATETIME_GETDATE_METHODDEF    \
    {"date", _PyCFunction_CAST(datetime_datetime_getdate), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_getdate__doc__},

static PyObject *
datetime_datetime_getdate_impl(PyDateTime_DateTime *self,
                               PyTypeObject *defcls);

static PyObject *
datetime_datetime_getdate(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "date() takes no arguments");
        return NULL;
    }
    return datetime_datetime_getdate_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_gettime__doc__,
"time($self, /)\n"
"--\n"
"\n"
"Return time object with same time but with tzinfo=None.");

#define DATETIME_DATETIME_GETTIME_METHODDEF    \
    {"time", _PyCFunction_CAST(datetime_datetime_gettime), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_gettime__doc__},

static PyObject *
datetime_datetime_gettime_impl(PyDateTime_DateTime *self,
                               PyTypeObject *defcls);

static PyObject *
datetime_datetime_gettime(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "time() takes no arguments");
        return NULL;
    }
    return datetime_datetime_gettime_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_gettimetz__doc__,
"timetz($self, /)\n"
"--\n"
"\n"
"Return time object with same time and tzinfo.");

#define DATETIME_DATETIME_GETTIMETZ_METHODDEF    \
    {"timetz", _PyCFunction_CAST(datetime_datetime_gettimetz), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_gettimetz__doc__},

static PyObject *
datetime_datetime_gettimetz_impl(PyDateTime_DateTime *self,
                                 PyTypeObject *defcls);

static PyObject *
datetime_datetime_gettimetz(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "timetz() takes no arguments");
        return NULL;
    }
    return datetime_datetime_gettimetz_impl(self, defcls);
}

PyDoc_STRVAR(datetime_datetime_utctimetuple__doc__,
"utctimetuple($self, /)\n"
"--\n"
"\n"
"Return UTC time tuple, compatible with time.localtime().");

#define DATETIME_DATETIME_UTCTIMETUPLE_METHODDEF    \
    {"utctimetuple", _PyCFunction_CAST(datetime_datetime_utctimetuple), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, datetime_datetime_utctimetuple__doc__},

static PyObject *
datetime_datetime_utctimetuple_impl(PyDateTime_DateTime *self,
                                    PyTypeObject *defcls);

static PyObject *
datetime_datetime_utctimetuple(PyDateTime_DateTime *self, PyTypeObject *defcls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "utctimetuple() takes no arguments");
        return NULL;
    }
    return datetime_datetime_utctimetuple_impl(self, defcls);
}
/*[clinic end generated code: output=8e2d5fc079c3daeb input=a9049054013a1b77]*/
